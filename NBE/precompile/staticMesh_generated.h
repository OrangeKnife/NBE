// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_STATICMESH_NBESTATICMESH_H_
#define FLATBUFFERS_GENERATED_STATICMESH_NBESTATICMESH_H_

#include "flatbuffers/flatbuffers.h"


namespace NBESTATICMESH {

struct Vec2;
struct Vec3;
struct Vec4;
struct TexMap;
struct Material;
struct StaticMeshVertex;
struct Batch;
struct StaticMeshData;

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2(float x, float y)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(float x) { flatbuffers::WriteScalar(&x_, x); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(float y) { flatbuffers::WriteScalar(&y_, y); }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3(float x, float y, float z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(float x) { flatbuffers::WriteScalar(&x_, x); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(float y) { flatbuffers::WriteScalar(&y_, y); }
  float z() const { return flatbuffers::EndianScalar(z_); }
  void mutate_z(float z) { flatbuffers::WriteScalar(&z_, z); }
};
STRUCT_END(Vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4(float x, float y, float z, float w)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)), w_(flatbuffers::EndianScalar(w)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(float x) { flatbuffers::WriteScalar(&x_, x); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(float y) { flatbuffers::WriteScalar(&y_, y); }
  float z() const { return flatbuffers::EndianScalar(z_); }
  void mutate_z(float z) { flatbuffers::WriteScalar(&z_, z); }
  float w() const { return flatbuffers::EndianScalar(w_); }
  void mutate_w(float w) { flatbuffers::WriteScalar(&w_, w); }
};
STRUCT_END(Vec4, 16);

MANUALLY_ALIGNED_STRUCT(4) StaticMeshVertex FLATBUFFERS_FINAL_CLASS {
 private:
  Vec3 pos_;
  Vec3 normal_;
  Vec4 color_;
  Vec2 uv_;

 public:
  StaticMeshVertex(const Vec3 &pos, const Vec3 &normal, const Vec4 &color, const Vec2 &uv)
    : pos_(pos), normal_(normal), color_(color), uv_(uv) { }

  const Vec3 &pos() const { return pos_; }
  Vec3 &mutable_pos() { return pos_; }
  const Vec3 &normal() const { return normal_; }
  Vec3 &mutable_normal() { return normal_; }
  const Vec4 &color() const { return color_; }
  Vec4 &mutable_color() { return color_; }
  const Vec2 &uv() const { return uv_; }
  Vec2 &mutable_uv() { return uv_; }
};
STRUCT_END(StaticMeshVertex, 48);

MANUALLY_ALIGNED_STRUCT(4) Batch FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t materialId_;
  uint32_t startIndex_;
  uint32_t size_;

 public:
  Batch(int32_t materialId, uint32_t startIndex, uint32_t size)
    : materialId_(flatbuffers::EndianScalar(materialId)), startIndex_(flatbuffers::EndianScalar(startIndex)), size_(flatbuffers::EndianScalar(size)) { }

  int32_t materialId() const { return flatbuffers::EndianScalar(materialId_); }
  void mutate_materialId(int32_t materialId) { flatbuffers::WriteScalar(&materialId_, materialId); }
  uint32_t startIndex() const { return flatbuffers::EndianScalar(startIndex_); }
  void mutate_startIndex(uint32_t startIndex) { flatbuffers::WriteScalar(&startIndex_, startIndex); }
  uint32_t size() const { return flatbuffers::EndianScalar(size_); }
  void mutate_size(uint32_t size) { flatbuffers::WriteScalar(&size_, size); }
};
STRUCT_END(Batch, 12);

struct TexMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *texMapFileName() const { return GetPointer<const flatbuffers::String *>(4); }
  flatbuffers::String *mutable_texMapFileName() { return GetPointer<flatbuffers::String *>(4); }
  int32_t texMapSlot() const { return GetField<int32_t>(6, -1); }
  bool mutate_texMapSlot(int32_t texMapSlot) { return SetField(6, texMapSlot); }
  int32_t texId() const { return GetField<int32_t>(8, -1); }
  bool mutate_texId(int32_t texId) { return SetField(8, texId); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* texMapFileName */) &&
           verifier.Verify(texMapFileName()) &&
           VerifyField<int32_t>(verifier, 6 /* texMapSlot */) &&
           VerifyField<int32_t>(verifier, 8 /* texId */) &&
           verifier.EndTable();
  }
};

struct TexMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_texMapFileName(flatbuffers::Offset<flatbuffers::String> texMapFileName) { fbb_.AddOffset(4, texMapFileName); }
  void add_texMapSlot(int32_t texMapSlot) { fbb_.AddElement<int32_t>(6, texMapSlot, -1); }
  void add_texId(int32_t texId) { fbb_.AddElement<int32_t>(8, texId, -1); }
  TexMapBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TexMapBuilder &operator=(const TexMapBuilder &);
  flatbuffers::Offset<TexMap> Finish() {
    auto o = flatbuffers::Offset<TexMap>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<TexMap> CreateTexMap(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> texMapFileName = 0,
   int32_t texMapSlot = -1,
   int32_t texId = -1) {
  TexMapBuilder builder_(_fbb);
  builder_.add_texId(texId);
  builder_.add_texMapSlot(texMapSlot);
  builder_.add_texMapFileName(texMapFileName);
  return builder_.Finish();
}

struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *materialName() const { return GetPointer<const flatbuffers::String *>(4); }
  flatbuffers::String *mutable_materialName() { return GetPointer<flatbuffers::String *>(4); }
  const flatbuffers::Vector<flatbuffers::Offset<TexMap>> *textureMaps() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TexMap>> *>(6); }
  flatbuffers::Vector<flatbuffers::Offset<TexMap>> *mutable_textureMaps() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<TexMap>> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* materialName */) &&
           verifier.Verify(materialName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* textureMaps */) &&
           verifier.Verify(textureMaps()) &&
           verifier.VerifyVectorOfTables(textureMaps()) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_materialName(flatbuffers::Offset<flatbuffers::String> materialName) { fbb_.AddOffset(4, materialName); }
  void add_textureMaps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TexMap>>> textureMaps) { fbb_.AddOffset(6, textureMaps); }
  MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MaterialBuilder &operator=(const MaterialBuilder &);
  flatbuffers::Offset<Material> Finish() {
    auto o = flatbuffers::Offset<Material>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> materialName = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TexMap>>> textureMaps = 0) {
  MaterialBuilder builder_(_fbb);
  builder_.add_textureMaps(textureMaps);
  builder_.add_materialName(materialName);
  return builder_.Finish();
}

struct StaticMeshData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *staticMeshName() const { return GetPointer<const flatbuffers::String *>(4); }
  flatbuffers::String *mutable_staticMeshName() { return GetPointer<flatbuffers::String *>(4); }
  const flatbuffers::Vector<const StaticMeshVertex *> *vertices() const { return GetPointer<const flatbuffers::Vector<const StaticMeshVertex *> *>(6); }
  flatbuffers::Vector<const StaticMeshVertex *> *mutable_vertices() { return GetPointer<flatbuffers::Vector<const StaticMeshVertex *> *>(6); }
  const flatbuffers::Vector<uint32_t> *indices() const { return GetPointer<const flatbuffers::Vector<uint32_t> *>(8); }
  flatbuffers::Vector<uint32_t> *mutable_indices() { return GetPointer<flatbuffers::Vector<uint32_t> *>(8); }
  const flatbuffers::Vector<flatbuffers::Offset<Material>> *materials() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Material>> *>(10); }
  flatbuffers::Vector<flatbuffers::Offset<Material>> *mutable_materials() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Material>> *>(10); }
  const flatbuffers::Vector<const Batch *> *batches() const { return GetPointer<const flatbuffers::Vector<const Batch *> *>(12); }
  flatbuffers::Vector<const Batch *> *mutable_batches() { return GetPointer<flatbuffers::Vector<const Batch *> *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* staticMeshName */) &&
           verifier.Verify(staticMeshName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* vertices */) &&
           verifier.Verify(vertices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* indices */) &&
           verifier.Verify(indices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* materials */) &&
           verifier.Verify(materials()) &&
           verifier.VerifyVectorOfTables(materials()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* batches */) &&
           verifier.Verify(batches()) &&
           verifier.EndTable();
  }
};

struct StaticMeshDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_staticMeshName(flatbuffers::Offset<flatbuffers::String> staticMeshName) { fbb_.AddOffset(4, staticMeshName); }
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<const StaticMeshVertex *>> vertices) { fbb_.AddOffset(6, vertices); }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> indices) { fbb_.AddOffset(8, indices); }
  void add_materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Material>>> materials) { fbb_.AddOffset(10, materials); }
  void add_batches(flatbuffers::Offset<flatbuffers::Vector<const Batch *>> batches) { fbb_.AddOffset(12, batches); }
  StaticMeshDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  StaticMeshDataBuilder &operator=(const StaticMeshDataBuilder &);
  flatbuffers::Offset<StaticMeshData> Finish() {
    auto o = flatbuffers::Offset<StaticMeshData>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<StaticMeshData> CreateStaticMeshData(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> staticMeshName = 0,
   flatbuffers::Offset<flatbuffers::Vector<const StaticMeshVertex *>> vertices = 0,
   flatbuffers::Offset<flatbuffers::Vector<uint32_t>> indices = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Material>>> materials = 0,
   flatbuffers::Offset<flatbuffers::Vector<const Batch *>> batches = 0) {
  StaticMeshDataBuilder builder_(_fbb);
  builder_.add_batches(batches);
  builder_.add_materials(materials);
  builder_.add_indices(indices);
  builder_.add_vertices(vertices);
  builder_.add_staticMeshName(staticMeshName);
  return builder_.Finish();
}

inline const NBESTATICMESH::StaticMeshData *GetStaticMeshData(const void *buf) { return flatbuffers::GetRoot<NBESTATICMESH::StaticMeshData>(buf); }

inline StaticMeshData *GetMutableStaticMeshData(void *buf) { return flatbuffers::GetMutableRoot<StaticMeshData>(buf); }

inline bool VerifyStaticMeshDataBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<NBESTATICMESH::StaticMeshData>(); }

inline void FinishStaticMeshDataBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<NBESTATICMESH::StaticMeshData> root) { fbb.Finish(root); }

}  // namespace NBESTATICMESH

#endif  // FLATBUFFERS_GENERATED_STATICMESH_NBESTATICMESH_H_
